### Коллекции - это группа элементов или контейнеров, представленных в виде единого целого.

1. Любой класс, реализующий интерфейс java.lang.Collection
2. Классы, включенные в Collection Framework
3. Любой класс, задача которого содержать в себе ряд объектов другого класса

### Что может делать коллекция?

**Любая коллекция должна иметь возможность:**
1. Добавить новый элемент
2. Получить элемент
3. Удалить элемент
4. Проверить наличие элемента 
5. Перебрать элементы или пройтись по элементам 

**Более сложные операции:**
1. Слияние 2-х коллекций
2. Выделение части коллекции в качестве новой коллекции
3. Защита состояния при многопоточном исполнении

### Что не могут коллекции?
1. Работать с примитивами
2. Специализироваться в зависимости от типа данных

### Зачем нужны коллекции?
1. Уменьшение затрат времени при программировании
2. Улучшение производительности
3. Ускорение обучения
4. Взаимосвязь с другими частями приложения
5. Упрощение переноса кода

### Реализация Коллекций в Java
1. [x] Все коллекции в Java - это обобщения (Generics)
2. [x] Все коллекции реализуют ряд интерфейсов
3. [x] Коллекции вправе выбросить исключение типа java.lang.UnsupportedOperationException

### Как работать с коллекцией?
1. Понять, что нужно будет делать с коллекцией и это станет интерфейсом
2. Решить какая реализация подходит для задачи и это станет оъектом
```java
    Collection<Integer> collection = new LinkCollection<Integer>();
```
Где, 
```
Collection<Integer> ... - базовый интерфейс коллекции
new LinkCollection<Integer>() - реализация коллекции через связный список
``` 

**При создании методов нужно отталкиваться от интерфейсов:**
```java
    public void testFunction(List<Integer> list) throws UnsupportedOperationException {
        System.out.println();
    }
```
Здесь коллекция будет использоваться как список, но не обязательно указывать какой именно список: 
ArrayList, Vector или другой


### Методы коллекции Списка(LIST):
1. ```add() - добавить элемент```
2. ```addAll() - добавление любой другой коллекции```
3. ```get() - получить элемент по индексу```
4. ```contains() - проверить содержание```
5. ```containsAll() - проверить содержание```
6. ```sublist() - получает индекс начала и конца и возвращает список```
7. ```toArray() - преобразует список в массив```
8. ```listIterator() - ListIterator в Java может проходить по списку в обоих направлениях, включая от конца к началу. Это одна из ключевых особенностей ListIterator, которая отличает его от обычного Iterator.```


```
Предупреждение Call to 'list. containsAll(collection)' may have poor performance связано с потенциально низкой 
производительностью вызова `containsAll()` в случае, если `firstList` является реализацией, где поиск элементов 
выполняется неэффективно, например, в `ArrayList`. Давайте разберемся, почему это важно.
```
### Почему `containsAll()` может иметь низкую производительность?

Метод `containsAll(Collection<?> c)` проверяет, содержатся ли все элементы из указанной коллекции `c` в текущем списке. Если ваш список реализован на основе `ArrayList`, то для каждого элемента из `c` выполняется линейный поиск по `firstList`. Это делает сложность операции `O(n * m)`, где `n` — размер `firstList`, а `m` — размер `secondList`.

### Оптимизация через `HashSet`

Когда вы создаете `HashSet` из `firstList`, вы улучшаете производительность до `O(n + m)`. Это достигается тем, что `HashSet` обеспечивает доступ к элементам за амортизированное `O(1)` время, поэтому проверка наличия каждого элемента из `secondList` становится значительно быстрее:

```java
boolean containsAll = new HashSet<>(firstList).containsAll(secondList);
```

### Когда это имеет значение?

Эта оптимизация имеет наибольшее значение, когда:
- `firstList` и `secondList` имеют значительный размер.
- Производительность важна для вашего приложения, и вы замечаете, что вызов `containsAll()` является "узким местом".

### Заключение

Если производительность критична, и вы работаете с большими данными, то преобразование `firstList` в `HashSet` перед вызовом `containsAll()` может быть полезным. В противном случае, если списки малы или производительность не является проблемой, стандартное использование `containsAll()` без преобразования может быть вполне приемлемым.


**Источник:**
https://www.youtube.com/watch?v=H8YOHx1dLMI&list=PLY7PmJJFH5nSaAcsqTEKpzaFJe7DZUYRM

**Автор:**
Volodya Mozhenkov
